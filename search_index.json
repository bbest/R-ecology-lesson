[
["index.html", "R for Data Analysis in Ecology Chapter 1 Overview 1.1 Lessons 1.2 Data 1.3 Other resources", " R for Data Analysis in Ecology 2016-08-15 Chapter 1 Overview Content Contributors: Sarah Supp, John Blischak, Gavin Simpson, Tracy Teal, Greg Wilson, Diego Barneche, Stephen Turner, Francois Michonneau Lesson Maintainers: Francois Michonneau, Auriel Fournier** Lesson status: Teaching 1.1 Lessons Lesson 00 Before we start Lesson 01 Introduction to R Lesson 02 Starting with data Lesson 03 Introducing data.frame Lesson 04 Aggregating and analyzing data with dplyr Lesson 05 Data visualization with ggplot2 Lesson 06 R and SQL 1.2 Data Data files for the lesson are available here: http://dx.doi.org/10.6084/m9.figshare.1314459 Please download the *.csv (Comma Separated Value) files: species.csv, plots.csv, surveys.csv, and combined.csv. 1.2.1 Requirements Data Carpentry’s teaching is hands-on, so participants are encouraged to use their own computers to insure the proper setup of tools for an efficient workflow. These lessons assume no prior knowledge of the skills or tools, but working through this lesson requires working copies of the software described below. To most effectively use these materials, please make sure to install everything before working through this lesson. 1.2.2 R R is a programming language that is especially powerful for data exploration, visualization, and statistical analysis. To interact with R, we use RStudio. Make sure you have a recent version of R ( or higher). 1.2.2.1 Windows Install R by downloading and running this .exe file from CRAN. Also, please install the RStudio IDE. 1.2.2.2 Mac OS X Install R by downloading and running this .pkg file from CRAN. If you have Snow Leopard, you might run into issues when trying to download the datasets directly from R using the download.file() function. If it’s the case, you will need to download the data files manually. Don’t hesitate to ask the instructor for help if you run into issues. Also, please install the RStudio IDE. 1.2.2.3 Linux You can download the binary files for your distribution from CRAN. Or you can use your package manager (e.g. for Debian/Ubuntu run sudo apt-get install r-base and for Fedora run sudo yum install R). This workshop requires a version of R no older than version 3.2.2; the default software repositories for some Linux distributions maybe out of date. It is recommended that you use a more recent version of R by adding the relevant entries to your package manager. See the instructions for your distribution on the CRAN website. Also, please install the RStudio IDE. 1.3 Other resources Why use R? Twitter: @datacarpentry "],
["before-we-start.html", "Chapter 2 Before we start 2 Learning Objectives 2.1 Organizing your working directory 2.2 Presentation of RStudio 2.3 Interacting with R 2.4 Basics of R 2.5 Seeking help 2.6 I am stuck… I get an error message that I don’t understand", " Chapter 2 Before we start 2 Learning Objectives After completing this module, the learner should be able to: Organize files and directories related to a particular set of analyses in an R Project within RStudio Define the following (as they apply to R): Script, function, working directory, assign, object, variable Describe the purpose of the RStudio script, console, environment, and plot windows Assign values to variables Call functions with zero or more named or unnamed arguments Use the built-in RStudio help interface to search for more information on R functions Ask for help from the R user community, providing sufficient information for the problem to be reproduced and troubleshooted It is good practice to keep a set of related data, analyses, and text self-contained in a single folder, called the working directory. All of the scripts within this folder can then use relative paths to files that indicate where inside the project a file is located (as opposed to absolute paths, which point to where a file is on a specific computer). Working this way makes it a lot easier to move your project around on your computer and share it with others without worrying about whether or not the underlying scripts will still work. RStudio provides a helpful set of tools to do this through its “Projects” interface, which not only creates a working directory for you but also remembers its location (allowing you to quickly navigate to it) and optonally preserves custom settings and open files to make it easier to resume work after a break. Below, we will go through the steps for creating an RProject for this tutorial. Start RStudio (presentation of RStudio -below- should happen here) Under the File menu, click on New project, choose New directory, then Empty project Enter a name for this new folder (or “directory”, in computer science), and choose a convenient location for it. This will be your working directory for the rest of the day (e.g., ~/data-carpentry) Click on “Create project” Under the Files tab on the right of the screen, click on New Folder and create a folder named data within your newly created working directory. (e.g., ~/data-carpentry/data) Create a new R script (File &gt; New File &gt; R script) and save it in your working directory (e.g. data-carpentry-script.R) Your working directory should now look like this: How it should look like at the beginning of this lesson 2.1 Organizing your working directory Using a consistent folder structure across your projects will help keep things organized, and will also make it easy find/file things in the future. This can be especially helpful when you have multiple projects. In general, you may create directories (folders) for scripts, data, and documents. data/ Use this folder to store your raw data and intermediate datasets you may create for the need of a particular analysis. For the sake of transparency and provenance, you should always keep a copy of your raw data accessible and do as much of your data cleanup and preprocessing programmatically (i.e. with scripts, rather than manually) as possible. Separating raw data from processed data is also a good idea. For example, you could have files data/raw/tree_survey.plot1.txt and ...plot2.txt kept separate from a data/processed/tree.survey.csv file generated by the scripts/01.preprocess.tree_survey.R script. documents/ This would be a place to keep outlines, drafts, and other text. scripts/ This would be the location to keep your R scripts for different analyses or plotting, and potentially a separate folder for your functions (more on that later). You may want additional directories or subdirectories depending on your project needs, but these should form the backbone of your working directory. For this workshop, you only need a data/ folder. Example of a working directory structure 2.2 Presentation of RStudio Let’s start by learning about RStudio, the Integrated Development Environment (IDE). The RStudio IDE open source product is free under the Affero General Public License (AGPL) v3. Rstudio IDE is also available with a commercial license and priority email support from Rstudio, Inc. We will use Rstudio IDE to write code, navigate the files found on our computer, inspect the variables we are going to create, and visualize the plots we will generate. RStudio can also be used for other things (e.g., version control, developing packages, writting Shiny apps) that we will not cover during the workshop. RStudio is divided into 4 “Panes”: the editor for your scripts and documents (top-left), the R console (bottom-left), your environment/history (top-right), and your files/plots/packages/help/viewer (bottom-right). The placement of these panes and their content can be customized. One of the advantages of using RStudio is that all the information you need to write code is available in a single window. Additionally, with many shortcuts, autocompletion, and highlighting for the major file types you use while developping in R, RStudio will make typing easier and less error-prone. 2.3 Interacting with R The basis of programming is that we write down instructions for the computer to follow, and then we tell the computer to follow those instructions. We write, or code, instructions in R because it is a common language that both the computer and we can understand. We call the instructions commands and we tell the computer to follow the instructions by executing (also called running) those commands. There are two main ways of interacting with R: using the console or by using script files (plain text files that contain your code). We want our code and workflow to be reproducible. In other words, we want to write code in a way that anyone can easily replicate, such they can obtain the same results from our code on their computer. The console pane (in RStudio, the bottom left panel) is the place where R is waiting for you to tell it what to do, and where it will show the results of a command that has been executed. You can type commands directly into the console and press Enter to execute those commands, but they will be forgotten when you close the session. It is better to enter the commands in the script editor, and save the script. This way, you have a complete record of what you did, you can easily show others how you did it and you can do it again later on if needed. RStudio allows you to execute commands directly from the script editor by using the Ctrl + Enter shortcut. The command on the current line in the script or all of the commands in the currently selected text will be sent to the console and executed when you press Ctrl + Enter. At some point in your analysis you may want to check the content of variable or the structure of an object, without necessarily keep a record of it in your script. You can type these commands and execute them directly in the console. RStudio provides the Ctrl + 1 and Ctrl + 2 shortcuts allow you to jump between the script and the console windows. If R is ready to accept commands, the R console shows a &gt; prompt. If it receives a command (by typing, copy-pasting or sent from the script editor using Ctrl + Enter), R will try to execute it, and when ready, show the results and come back with a new &gt;-prompt to wait for new commands. If R is still waiting for you to enter more data because it isn’t complete yet, the console will show a + prompt. It means that you haven’t finished entering a complete command. This is because you have not ‘closed’ a parenthesis or quotation, i.e. you don’t have the same number of left-parentheses as right-parentheses, or the same number of opening and closing quotation marks. If you’re in RStudio and this happens, click inside the console window and press Esc; this will cancel the incomplete command and return you to the &gt; prompt. 2.4 Basics of R R is a versatile, open source programming/scripting language that’s useful both for statistics but also data science. Inspired by the programming language S. Free/Libre/Open Source Software under the GPL version 2. Superior (if not just comparable) to commercial alternatives. R has over 7,000 user contributed packages at this time. It’s widely used both in academia and industry. Available on all platforms. Not just for statistics, but also general purpose programming. For people who have experience in programmming: R is both an object-oriented and a so-called functional language. Large and growing community of peers. 2.4.1 The R syntax Start by showing an example of a script Point to the different parts: a function the assignment operator &lt;- the = for arguments the comments # and how they are used to document function and its content the $ operator Point to indentation and consistency in spacing to improve clarity Example of a simple R script 2.4.1.1 Commenting Use # signs to comment. Anything to the right of a # is ignored by R, meaning it won’t be executed. Comments are a great way to describe what your code does within the code itself, so comment liberally in your R scripts. 2.4.1.2 Assignment operator &lt;- is the assignment operator. It assigns values on the right to objects on the left. So, after executing x &lt;- 3, the value of x is 3. The arrow can be read as 3 goes into x. For historical reasons, you can also use = for assignments, but not in every context. Because of the slight differences in syntax, it is good practice to use always &lt;- for assignments, except when specifying the values of arguments in functions, when only = should be used, see below. In RStudio, typing Alt + - (push Alt at the same time as the - key) will write &lt;- in a single keystroke. 2.4.1.3 Functions and their arguments Functions are “canned scripts” that automate something complicated or convenient or both. Many functions are predefined, or can be made available by importing R packages (more on that later). A function usually gets one or more inputs called arguments. Functions often (but not always) return a value. A typical example would be the function sqrt(). The input (the argument) must be a number, and the return value (in fact, the output) is the square root of that number. Executing a function (‘running it’) is called calling the function. An example of a function call is: b &lt;- sqrt(a) Here, the value of a is given to the sqrt() function, the sqrt() function calculates the square root, and returns the value which is then assigned to variable b. This function is very simple, because it takes just one argument. The return ‘value’ of a function need not be numerical (like that of sqrt()), and it also does not need to be a single item: it can be a set of things, or even a data set. We’ll see that when we read data files in to R. Arguments can be anything, not only numbers or filenames, but also other objects. Exactly what each argument means differs per function, and must be looked up in the documentation (see below). Some functions take arguments which may either be specified by the user, or if left out, take on a default value: these are called options. Options are typically used to alter the way the function operates, such as whether it ignores ‘bad values’, or what symbol to use in a plot. However, if you want something specific, you can specify a value of your choice which will be used instead of the default. Let’s try a function that can take multiple arguments: round(). round(3.14159) ## [1] 3 Here, we’ve called round() with just one argument, 3.14159, and it has returned the value 3. That’s because the default is to round to the nearest whole number. If we want more digits we can see how to do that by getting information about the round function. We can use args(round) or look at the help for this function using ?round. args(round) ## function (x, digits = 0) ## NULL ?round We see that if we want a different number of digits, we can type digits=2 or however many we want. round(3.14159, digits=2) ## [1] 3.14 If you provide the arguments in the exact same order as they are defined you don’t have to name them: round(3.14159, 2) ## [1] 3.14 And if you do name the arguments, you can switch their order: round(digits=2, x=3.14159) ## [1] 3.14 It’s good practice to put the non-optional arguments (like the number you’re rounding) first in your function call, and to specify the names of all optional arguments. If you don’t, someone reading your code might have to look up definition of a function with unfamiliar arguments to understand what you’re doing. 2.5 Seeking help 2.5.1 I know the name of the function I want to use, but I’m not sure how to use it If you need help with a specific function, let’s say barplot(), you can type: ?barplot If you just need to remind yourself of the names of the arguments, you can use: args(lm) 2.5.2 I want to use a function that does X, there must be a function for it but I don’t know which one… If you are looking for a function to do a particular task, you can use help.search() function, which is called by the double question mark ??. However, this only looks through the installed packages for help pages with a match to your search request ??kruskal If you can’t find what you are looking for, you can use the rdocumention.org website that search through the help files across all packages available. 2.6 I am stuck… I get an error message that I don’t understand Start by googling the error message. However, this doesn’t always work very well because often, package developers rely on the error catching provided by R. You end up with general error messages that might not be very helpful to diagnose a problem (e.g. “subscript out of bounds”). If the message is very generic, you might also include the name of the function or package you’re using in your query. However, you should check StackOverflow. Search using the [r] tag. Most questions have already been answered, but the challenge is to use the right words in the search to find the answers: http://stackoverflow.com/questions/tagged/r The Introduction to R can also be dense for people with little programming experience but it is a good place to understand the underpinnings of the R language. The R FAQ is dense and technical but it is full of useful information. 2.6.1 Asking for help The key to get help from someone is for them to grasp your problem rapidly. You should make it as easy as possible to pinpoint where the issue might be. Try to use the correct words to describe your problem. For instance, a package is not the same thing as a library. Most people will understand what you meant, but others have really strong feelings about the difference in meaning. The key point is that it can make things confusing for people trying to help you. Be as precise as possible when describing your problem. If possible, try to reduce what doesn’t work to a simple reproducible example. If you can reproduce the problem using a very small data.frame instead of your 50,000 rows and 10,000 columns one, provide the small one with the description of your problem. When appropriate, try to generalize what you are doing so even people who are not in your field can understand the question. For instance instead of using a subset of your real dataset, create a small (3 columns, 5 row) generic one. To share an object with someone else, if it’s relatively small, you can use the function dput(). It will output R code that can be used to recreate the exact same object as the one in memory: dput(head(iris)) # iris is an example data.frame that comes with R ## structure(list(Sepal.Length = c(5.1, 4.9, 4.7, 4.6, 5, 5.4), ## Sepal.Width = c(3.5, 3, 3.2, 3.1, 3.6, 3.9), Petal.Length = c(1.4, ## 1.4, 1.3, 1.5, 1.4, 1.7), Petal.Width = c(0.2, 0.2, 0.2, ## 0.2, 0.2, 0.4), Species = structure(c(1L, 1L, 1L, 1L, 1L, ## 1L), .Label = c(&quot;setosa&quot;, &quot;versicolor&quot;, &quot;virginica&quot;), class = &quot;factor&quot;)), .Names = c(&quot;Sepal.Length&quot;, ## &quot;Sepal.Width&quot;, &quot;Petal.Length&quot;, &quot;Petal.Width&quot;, &quot;Species&quot;), row.names = c(NA, ## 6L), class = &quot;data.frame&quot;) If the object is larger, provide either the raw file (i.e., your CSV file) with your script up to the point of the error (and after removing everything that is not relevant to your issue). Alternatively, in particular if your questions is not related to a data.frame, you can save any R object to a file: saveRDS(iris, file=&quot;/tmp/iris.rds&quot;) The content of this file is however not human readable and cannot be posted directly on stackoverflow. It can however be sent to someone by email who can read it with this command: some_data &lt;- readRDS(file=&quot;~/Downloads/iris.rds&quot;) Last, but certainly not least, always include the output of sessionInfo() as it provides critical information about your platform, the versions of R and the packages that you are using, and other information that can be very helpful to understand your problem. sessionInfo() ## R version 3.3.1 (2016-06-21) ## Platform: x86_64-apple-darwin13.4.0 (64-bit) ## Running under: OS X 10.11.6 (El Capitan) ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] Rcpp_0.12.6 bookdown_0.1.4 digest_0.6.10 mime_0.5 ## [5] R6_2.1.2 xtable_1.8-2 formatR_1.4 magrittr_1.5 ## [9] evaluate_0.9 stringi_1.1.1 rstudioapi_0.6 miniUI_0.1.1 ## [13] rmarkdown_1.0 tools_3.3.1 stringr_1.0.0 shiny_0.13.2 ## [17] httpuv_1.3.3 yaml_2.1.13 htmltools_0.3.5 knitr_1.14 2.6.2 Where to ask for help? Your friendly colleagues: if you know someone with more experience than you, they might be able and willing to help you. StackOverflow: if your question hasn’t been answered before and is well crafted, chances are you will get an answer in less than 5 min. The R-help mailing list: it is read by a lot of people (including most of the R core team), a lot of people post to it, but the tone can be pretty dry, and it is not always very welcoming to new users. If your question is valid, you are likely to get an answer very fast but don’t expect that it will come with smiley faces. Also, here more than everywhere else, be sure to use correct vocabulary (otherwise you might get an answer pointing to the misuse of your words rather than answering your question). You will also have more success if your question is about a base function rather than a specific package. If your question is about a specific package, see if there is a mailing list for it. Usually it’s included in the DESCRIPTION file of the package that can be accessed using packageDescription(&quot;name-of-package&quot;). You may also want to try to email the author of the package directly, or open an issue on the code repository (e.g., GitHub). There are also some topic-specific mailing lists (GIS, phylogenetics, etc…), the complete list is here. 2.6.3 More resources The Posting Guide for the R mailing lists. How to ask for R help useful guidelines This blog post by Jon Skeet has quite comprehensive advice on how to ask programming questions. "],
["intro-to-r.html", "Chapter 3 Introduction to R 3 Learning Objectives 3.1 Creating objects 3.2 Vectors and data types 3.3 Subsetting vectors 3.4 Missing data", " Chapter 3 Introduction to R 3 Learning Objectives Familiarize participants with R syntax Understand the concepts of objects and assignment Understand the concepts of vector and data types Get exposed to a few functions 3.1 Creating objects You can get output from R simply by typing in math in the console 3 + 5 12/7 However, to do useful and interesting things, we need to assign values to objects. To create an object, we need to give it a name followed by the assignment operator &lt;-, and the value we want to give it: weight_kg &lt;- 55 Objects can be given any name such as x, current_temperature, or subject_id. You want your object names to be explicit and not too long. They cannot start with a number (2x is not valid, but x2 is). R is case sensitive (e.g., weight_kg is different from Weight_kg). There are some names that cannot be used because they are the names of fundamental functions in R (e.g., if, else, for, see here for a complete list). In general, even if it’s allowed, it’s best to not use other function names (e.g., c, T, mean, data, df, weights). In doubt check the help to see if the name is already in use. It’s also best to avoid dots (.) within a variable name as in my.dataset. There are many functions in R with dots in their names for historical reasons, but because dots have a special meaning in R (for methods) and other programming languages, it’s best to avoid them. It is also recommended to use nouns for variable names, and verbs for function names. It’s important to be consistent in the styling of your code (where you put spaces, how you name variable, etc.). In R, two popular style guides are Hadley Wickham’s and Google’s. When assigning a value to an object, R does not print anything. You can force to print the value by using parentheses or by typing the name: weight_kg &lt;- 55 # doesn&#39;t print anything (weight_kg &lt;- 55) # but putting parenthesis around the call prints the value of `weight_kg` weight_kg # and so does typing the name of the object Now that R has weight_kg in memory, we can do arithmetic with it. For instance, we may want to convert this weight in pounds (weight in pounds is 2.2 times the weight in kg): 2.2 * weight_kg We can also change a variable’s value by assigning it a new one: weight_kg &lt;- 57.5 2.2 * weight_kg This means that assigning a value to one variable does not change the values of other variables. For example, let’s store the animal’s weight in pounds in a new variable, weight_lb: weight_lb &lt;- 2.2 * weight_kg and then change weight_kg to 100. weight_kg &lt;- 100 What do you think is the current content of the object weight_lb? 126.5 or 200? 3.1.1 Challenge What are the values after each statement in the following? mass &lt;- 47.5 # mass? age &lt;- 122 # age? mass &lt;- mass * 2.0 # mass? age &lt;- age - 20 # age? mass_index &lt;- mass/age # mass_index? 3.2 Vectors and data types A vector is the most common and basic data structure in R, and is pretty much the workhorse of R. It’s a group of values, mainly either numbers or characters. You can assign this list of values to a variable, just like you would for one item. For example we can create a vector of animal weights: weight_g &lt;- c(50, 60, 65, 82) weight_g A vector can also contain characters: animals &lt;- c(&quot;mouse&quot;, &quot;rat&quot;, &quot;dog&quot;) animals There are many functions that allow you to inspect the content of a vector. length() tells you how many elements are in a particular vector: length(weight_g) length(animals) An important feature of a vector, is that all of the elements are the same type of data. The function class() indicates the class (the type of element) of an object: class(weight_g) class(animals) The function str() provides an overview of the object and the elements it contains. It is a really useful function when working with large and complex objects: str(weight_g) str(animals) You can add elements to your vector by using the c() function: weight_g &lt;- c(weight_g, 90) # adding at the end of the vector weight_g &lt;- c(30, weight_g) # adding at the beginning of the vector weight_g What happens here is that we take the original vector weight_g, and we are adding another item first to the end of the other ones, and then another item at the beginning. We can do this over and over again to grow a vector, or assemble a dataset. As we program, this may be useful to add results that we are collecting or calculating. We just saw 2 of the 6 atomic vector types that R uses: &quot;character&quot; and &quot;numeric&quot;. These are the basic building blocks that all R objects are built from. The other 4 are: &quot;logical&quot; for TRUE and FALSE (the boolean data type) &quot;integer&quot; for integer numbers (e.g., 2L, the L indicates to R that it’s an integer) &quot;complex&quot; to represent complex numbers with real and imaginary parts (e.g., 1+4i) and that’s all we’re going to say about them &quot;raw&quot; that we won’t discuss further Vectors are one of the many data structures that R uses. Other important ones are lists (list), matrices (matrix), data frames (data.frame) and factors (factor). 3.2.1 Challenge Question: We’ve seen that atomic vectors can be of type character, numeric, integer, and logical. But what happens if we try to mix these types in a single vector? Question: What will happen in each of these examples? (hint: use class() to check the data type of your objects): num_char &lt;- c(1, 2, 3, &#39;a&#39;) num_logical &lt;- c(1, 2, 3, TRUE) char_logical &lt;- c(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, TRUE) tricky &lt;- c(1, 2, 3, &#39;4&#39;) Question: Why do you think it happens? Question: Can you draw a diagram that represents the hierarchy of the data types? numeric -> character 3.3 Subsetting vectors If we want to extract one or several values from a vector, we must provide one or several indices in square brackets. For instance: animals &lt;- c(&quot;mouse&quot;, &quot;rat&quot;, &quot;dog&quot;, &quot;cat&quot;) animals[2] #&gt; [1] &quot;rat&quot; animals[c(3, 2)] #&gt; [1] &quot;dog&quot; &quot;rat&quot; We can also repeat the indices to create an object with more elements than the original one: more_animals &lt;- animals[c(1, 2, 3, 2, 1, 4)] more_animals #&gt; [1] &quot;mouse&quot; &quot;rat&quot; &quot;dog&quot; &quot;rat&quot; &quot;mouse&quot; &quot;cat&quot; R indexes start at 1. Programming languages like Fortran, MATLAB, and R start counting at 1, because that’s what human beings typically do. Languages in the C family (including C++, Java, Perl, and Python) count from 0 because that’s simpler for computers to do. 3.3.1 Conditional subsetting Another common way of subsetting is by using a logical vector: TRUE will select the element with the same index, while FALSE will not: weight_g &lt;- c(21, 34, 39, 54, 55) weight_g[c(TRUE, FALSE, TRUE, TRUE, FALSE)] #&gt; [1] 21 39 54 Typically, these logical vectors are not typed by hand, but are the output of other functions or logical tests. For instance, if you wanted to select only the values above 50: weight_g &gt; 50 # will return logicals with TRUE for the indices that meet the condition #&gt; [1] FALSE FALSE FALSE TRUE TRUE ## so we can use this to select only the values above 50 weight_g[weight_g &gt; 50] #&gt; [1] 54 55 You can combine multiple tests using &amp; (both conditions are true, AND) or | (at least one of the conditions is true, OR): weight_g[weight_g &lt; 30 | weight_g &gt; 50] #&gt; [1] 21 54 55 weight_g[weight_g &gt;= 30 &amp; weight_g == 21] #&gt; numeric(0) When working with vectors of characters, if you are trying to combine many conditions it can become tedious to type. The function %in% allows you to test if a value is found in a vector: animals &lt;- c(&quot;mouse&quot;, &quot;rat&quot;, &quot;dog&quot;, &quot;cat&quot;) animals[animals == &quot;cat&quot; | animals == &quot;rat&quot;] # returns both rat and cat #&gt; [1] &quot;rat&quot; &quot;cat&quot; animals %in% c(&quot;rat&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;duck&quot;) #&gt; [1] FALSE TRUE TRUE TRUE animals[animals %in% c(&quot;rat&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;duck&quot;)] #&gt; [1] &quot;rat&quot; &quot;dog&quot; &quot;cat&quot; 3.3.1 Challenge Can you figure out why &quot;four&quot; &gt; &quot;five&quot; returns TRUE? \" or \" 3.4 Missing data As R was designed to analyze datasets, it includes the concept of missing data (which is uncommon in other programming languages). Missing data are represented in vectors as NA. planets &lt;- c(&quot;Mercury&quot;, &quot;Venus&quot;, &quot;Earth&quot;, &quot;Mars&quot;, &quot;Jupiter&quot;, &quot;Saturn&quot;, &quot;Uranus&quot;, &quot;Neptune&quot;, NA) When doing operations on numbers, most functions will return NA if the data you are working with include missing values. It is a safer behavior as otherwise you may overlook that you are dealing with missing data. You can add the argument na.rm=TRUE to calculate the result while ignoring the missing values. heights &lt;- c(2, 4, 4, NA, 6) mean(heights) max(heights) mean(heights, na.rm = TRUE) max(heights, na.rm = TRUE) If your data include missing values, you may want to become familiar with the functions is.na(), na.omit(), and complete.cases(). See below for examples. ## Extract those elements which are not missing values. heights[!is.na(heights)] ## Returns the object with incomplete cases removed. The returned object is atomic. na.omit(heights) ## Extract those elements which are complete cases. heights[complete.cases(heights)] 3.4.1 Challenge Question: Why does the following piece of code give an error message? sample &lt;- c(2, 4, 4, &quot;NA&quot;, 6) mean(sample, na.rm = TRUE) #&gt; Warning in mean.default(sample, na.rm = TRUE): argument is not numeric or #&gt; logical: returning NA Question: Why does the error message say the argument is not numeric? Next, we will use the “surveys” dataset to explore the data.frame data structure, which is one of the most common types of R objects. "],
["starting-with-data.html", "Chapter 4 Starting with data 4 Learning Objectives 4.1 Presentation of the Survey Data 4.2 Factors", " Chapter 4 Starting with data 4 Learning Objectives load external data (CSV files) in memory using the survey table (surveys.csv) as an example explore the structure and the content of a data frame in R understand what factors are and how to manipulate them 4.1 Presentation of the Survey Data We are studying the species and weight of animals caught in plots in our study area. The dataset is stored as a CSV file: each row holds information for a single animal, and the columns represent: Column Description record_id Unique id for the observation month month of observation day day of observation year year of observation plot_id ID of a particular plot species_id 2-letter code sex sex of animal (“M”, “F”) hindfoot_length length of the hindfoot in mm weight weight of the animal in grams genus genus of animal species species of animal taxa e.g. Rodent, Reptile, Bird, Rabbit plot_type type of plot We are going to use the R function download.file() to download the CSV file that contains the survey data from figshare, and we will use read.csv() to load into memory (as a data.frame) the content of the CSV file. To download the data into the data/ subdirectory, do: download.file(&quot;https://ndownloader.figshare.com/files/2292169&quot;, &quot;data/portal_data_joined.csv&quot;) You are now ready to load the data: surveys &lt;- read.csv(&#39;data/portal_data_joined.csv&#39;) This statement doesn’t produce any output because, as you might recall, assignment doesn’t display anything. If we want to check that our data has been loaded, we can print the variable’s value: surveys. Wow… that was a lot of output. At least it means the data loaded properly. Let’s check the top (the first 6 lines) of this data.frame using the function head(): head(surveys) #&gt; record_id month day year plot_id species_id sex hindfoot_length weight #&gt; 1 1 7 16 1977 2 NL M 32 NA #&gt; 2 72 8 19 1977 2 NL M 31 NA #&gt; 3 224 9 13 1977 2 NL NA NA #&gt; 4 266 10 16 1977 2 NL NA NA #&gt; 5 349 11 12 1977 2 NL NA NA #&gt; 6 363 11 12 1977 2 NL NA NA #&gt; genus species taxa plot_type #&gt; 1 Neotoma albigula Rodent Control #&gt; 2 Neotoma albigula Rodent Control #&gt; 3 Neotoma albigula Rodent Control #&gt; 4 Neotoma albigula Rodent Control #&gt; 5 Neotoma albigula Rodent Control #&gt; 6 Neotoma albigula Rodent Control A data.frame is the representation of data in the format of a table where the columns are vectors that all have the same length. Because each column is a vector, they all contain the same type of data. We can see this when inspecting the __str__ucture of a data.frame with the function str(): str(surveys) 4.1.1 Challenge Based on the output of str(surveys), can you answer the following questions? What is the class of the object surveys? How many rows and how many columns are in this object? How many species have been recorded during these surveys? As you can see, many of the columns consist of integers, however, the columns species and sex are of a special class called a factor. Before we learn more about the data.frame class, let’s talk about factors. They are very useful but not necessarily intuitive, and therefore require some attention. 4.2 Factors Factors are used to represent categorical data. Factors can be ordered or unordered, and understanding them is necessary for statistical analysis and for plotting. Factors are stored as integers, and have labels associated with these unique integers. While factors look (and often behave) like character vectors, they are actually integers under the hood, and you need to be careful when treating them like strings. Once created, factors can only contain a pre-defined set of values, known as levels. By default, R always sorts levels in alphabetical order. For instance, if you have a factor with 2 levels: sex &lt;- factor(c(&quot;male&quot;, &quot;female&quot;, &quot;female&quot;, &quot;male&quot;)) R will assign 1 to the level &quot;female&quot; and 2 to the level &quot;male&quot; (because f comes before m, even though the first element in this vector is &quot;male&quot;). You can check this by using the function levels(), and check the number of levels using nlevels(): levels(sex) nlevels(sex) Sometimes, the order of the factors does not matter, other times you might want to specify the order because it is meaningful (e.g., “low”, “medium”, “high”) or it is required by a particular type of analysis. Additionally, specifying the order of the levels allows for level comparison: food &lt;- factor(c(&quot;low&quot;, &quot;high&quot;, &quot;medium&quot;, &quot;high&quot;, &quot;low&quot;, &quot;medium&quot;, &quot;high&quot;)) levels(food) food &lt;- factor(food, levels=c(&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;)) levels(food) min(food) ## doesn&#39;t work #&gt; Error in Summary.factor(structure(c(1L, 3L, 2L, 3L, 1L, 2L, 3L), .Label = c(&quot;low&quot;, : &#39;min&#39; not meaningful for factors food &lt;- factor(food, levels=c(&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;), ordered=TRUE) levels(food) min(food) ## works! In R’s memory, these factors are represented by integers (1, 2, 3), but are more informative than integers because factors are self describing: &quot;low&quot;, &quot;medium&quot;, &quot;high&quot;&quot; is more descriptive than 1, 2, 3. Which is low? You wouldn’t be able to tell just from the integer data. Factors, on the other hand, have this information built in. It is particularly helpful when there are many levels (like the species in our example data set). 4.2.1 Converting factors If you need to convert a factor to a character vector, you use as.character(x). Converting factors where the levels appear as numbers (such as concentration levels) to a numeric vector is a little trickier. One method is to convert factors to characters and then numbers. Another method is to use the levels() function. Compare: f &lt;- factor(c(1, 5, 10, 2)) as.numeric(f) ## wrong! and there is no warning... as.numeric(as.character(f)) ## works... as.numeric(levels(f))[f] ## The recommended way. Notice that in the levels() approach, three important steps occur: We obtain all the factor levels using levels(f) We convert these levels to numeric values using as.numeric(levels(f)) We then access these numeric values using the underlying integers of the vector f inside the square brackets 4.2.2 Challenge The function table() tabulates observations and can be used to create bar plots quickly. For instance, the code below gives you a barplot of the number of observations. In which order are the treatments listed? How can you recreate this plot with “control” listed last instead of first? ## Challenge ## ## * In which order are the treatments listed? ## ## * How can you recreate this plot with &quot;control&quot; listed ## last instead of first? exprmt &lt;- factor(c(&quot;treat1&quot;, &quot;treat2&quot;, &quot;treat1&quot;, &quot;treat3&quot;, &quot;treat1&quot;, &quot;control&quot;, &quot;treat1&quot;, &quot;treat2&quot;, &quot;treat3&quot;)) table(exprmt) #&gt; exprmt #&gt; control treat1 treat2 treat3 #&gt; 1 4 2 2 barplot(table(exprmt)) ---> "],
["data-frames.html", "Chapter 5 The data.frame class 5 Learning Objectives 5.1 What are data frames? 5.2 Inspecting data.frame Objects 5.3 Indexing, Sequences, and Subsetting", " Chapter 5 The data.frame class 5 Learning Objectives understand the concept of a data.frame use sequences know how to access any element of a data.frame 5.1 What are data frames? Data frames are the de facto data structure for most tabular data, and what we use for statistics and plotting. A data frame is a collection of vectors of identical lengths. Each vector represents a column, and each vector can be of a different data type (e.g., characters, integers, factors). The str() function is useful to inspect the data types of the columns. A data frame can be created by hand, but most commonly they are generated by the functions read.csv() or read.table(); in other words, when importing spreadsheets from your hard drive (or the web). By default, when building or importing a data frame, the columns that contain characters (i.e., text) are coerced (=converted) into the factor data type. Depending on what you want to do with the data, you may want to keep these columns as character. To do so, read.csv() and read.table() have an argument called stringsAsFactors which can be set to FALSE: some_data &lt;- read.csv(&quot;data/some_file.csv&quot;, stringsAsFactors=FALSE) You can also create a data frame manually with the function data.frame(). This function can also take the argument stringsAsFactors. Compare the output of these examples, and compare the difference between when the data are being read as character, and when they are being read as factor. ## Compare the output of these examples, and compare the difference between when ## the data are being read as `character`, and when they are being read as ## `factor`. example_data &lt;- data.frame(animal=c(&quot;dog&quot;, &quot;cat&quot;, &quot;sea cucumber&quot;, &quot;sea urchin&quot;), feel=c(&quot;furry&quot;, &quot;furry&quot;, &quot;squishy&quot;, &quot;spiny&quot;), weight=c(45, 8, 1.1, 0.8)) str(example_data) #&gt; &#39;data.frame&#39;: 4 obs. of 3 variables: #&gt; $ animal: Factor w/ 4 levels &quot;cat&quot;,&quot;dog&quot;,&quot;sea cucumber&quot;,..: 2 1 3 4 #&gt; $ feel : Factor w/ 3 levels &quot;furry&quot;,&quot;spiny&quot;,..: 1 1 3 2 #&gt; $ weight: num 45 8 1.1 0.8 example_data &lt;- data.frame(animal=c(&quot;dog&quot;, &quot;cat&quot;, &quot;sea cucumber&quot;, &quot;sea urchin&quot;), feel=c(&quot;furry&quot;, &quot;furry&quot;, &quot;squishy&quot;, &quot;spiny&quot;), weight=c(45, 8, 1.1, 0.8), stringsAsFactors=FALSE) str(example_data) #&gt; &#39;data.frame&#39;: 4 obs. of 3 variables: #&gt; $ animal: chr &quot;dog&quot; &quot;cat&quot; &quot;sea cucumber&quot; &quot;sea urchin&quot; #&gt; $ feel : chr &quot;furry&quot; &quot;furry&quot; &quot;squishy&quot; &quot;spiny&quot; #&gt; $ weight: num 45 8 1.1 0.8 5.1.1 Challenge There are a few mistakes in this hand crafted data.frame, can you spot and fix them? Don’t hesitate to experiment! author_book &lt;- data.frame(author_first=c(&quot;Charles&quot;, &quot;Ernst&quot;, &quot;Theodosius&quot;), author_last=c(Darwin, Mayr, Dobzhansky), year=c(1942, 1970)) Can you predict the class for each of the columns in the following example? Check your guesses using str(country_climate): Are they what you expected? Why? Why not? What would have been different if we had added stringsAsFactors = FALSE to this call? What would you need to change to ensure that each column had the accurate data type? country_climate &lt;- data.frame(country=c(&quot;Canada&quot;, &quot;Panama&quot;, &quot;South Africa&quot;, &quot;Australia&quot;), climate=c(&quot;cold&quot;, &quot;hot&quot;, &quot;temperate&quot;, &quot;hot/temperate&quot;), temperature=c(10, 30, 18, &quot;15&quot;), northern_hemisphere=c(TRUE, TRUE, FALSE, &quot;FALSE&quot;), has_kangaroo=c(FALSE, FALSE, FALSE, 1)) We introduced you to the data.frame() function and read.csv(), but what if we are starting with some vectors? The best way to do this is to pass those vectors to the data.frame() function, similar to the above. color &lt;- c(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;) counts &lt;- c(50, 60, 65, 82) new_datarame &lt;- data.frame(colors = color, counts = counts) Try making your own new data frame from some vectors. You can check the data type of the new object using class(). The automatic conversion of data type is sometimes a blessing, sometimes an annoyance. Be aware that it exists, learn the rules, and double check that data you import in R are of the correct type within your data frame. If not, use it to your advantage to detect mistakes that might have been introduced during data entry (a letter in a column that should only contain numbers for instance.). 5.2 Inspecting data.frame Objects We already saw how the functions head() and str() can be useful to check the content and the structure of a data.frame. Here is a non-exhaustive list of functions to get a sense of the content/structure of the data. Size: dim() - returns a vector with the number of rows in the first element, and the number of columns as the second element (the dimensions of the object) nrow() - returns the number of rows ncol() - returns the number of columns Content: head() - shows the first 6 rows tail() - shows the last 6 rows Names: names() - returns the column names (synonym of colnames() for data.frame objects) rownames() - returns the row names Summary: str() - structure of the object and information about the class, length and content of each column summary() - summary statistics for each column Note: most of these functions are “generic”, they can be used on other types of objects besides data.frame. 5.3 Indexing, Sequences, and Subsetting : is a special function that creates numeric vectors of integers in increasing or decreasing order, test 1:10 and 10:1 for instance. The function seq() (for sequence) can be used to create more complex patterns: seq(1, 10, by=2) #&gt; [1] 1 3 5 7 9 seq(5, 10, length.out=3) #&gt; [1] 5.0 7.5 10.0 seq(50, by=5, length.out=10) #&gt; [1] 50 55 60 65 70 75 80 85 90 95 seq(1, 8, by=3) # sequence stops to stay below upper limit #&gt; [1] 1 4 7 Our survey data frame has rows and columns (it has 2 dimensions), if we want to extract some specific data from it, we need to specify the “coordinates” we want from it. Row numbers come first, followed by column numbers. However, note that different ways of specifying these coorinates lead to results with different classes. surveys[1] # first column in the data frame (as a data.frame) surveys[1, 1] # first element in the first column of the data frame (as a vector) surveys[1, 6] # first element in the 6th column (as a vector) surveys[1:3, 7] # first three elements in the 7th column (as a vector) surveys[3, ] # the 3rd element for all columns (as a data.frame) surveys[, 8] # the entire 8th column (as a vector) head_surveys &lt;- surveys[1:6, ] # equivalent to head(surveys) You can also exclude certain parts of a data frame surveys[,-1] #The whole data frame, except the first column surveys[-c(7:34786),] #equivalent to head(surveys) As well as using numeric values to subset a data.frame (or matrix), columns can be called by name, using one of the three following notations: surveys[&quot;species_id&quot;] # Result is a data.frame surveys[, &quot;species_id&quot;] # Result is a vector surveys[[&quot;species_id&quot;]] # Result is a vector surveys$species_id # Result is a vector For our purposes, these three notations are equivalent. However, the last one with the $ does partial matching on the name. So you could also select the column &quot;day&quot; by typing surveys$d. It’s a shortcut, as with all shortcuts, they can have dangerous consequences, and are best avoided. Besides, with auto-completion in RStudio, you rarely have to type more than a few characters to get the full and correct column name. 5.3.1 Challenge The function nrow() on a data.frame returns the number of rows. Use it, in conjuction with seq() to create a new data.frame called surveys_by_10 that includes every 10th row of the survey data frame starting at row 10 (10, 20, 30, …) Create a data.frame containing only the observations from row 1999 of the surveys dataset. Notice how nrow() gave you the number of rows in a data.frame? Use nrow() instead of a row number to make a data.frame with observations from only the last row of the surveys dataset. Now that you’ve seen how nrow() can be used to stand in for a row index, let’s combine that behavior with the - notation above to reproduce the behavior of head(surveys) excluding the 7th through final row of the surveys dataset. "],
["data-manip-dplyr.html", "Chapter 6 Data Manipulation using dplyr 6 Learning Objectives 6.1 What is dplyr? 6.2 Selecting columns and filtering rows 6.3 Pipes 6.4 Exporting data", " Chapter 6 Data Manipulation using dplyr 6 Learning Objectives Learn basic utilities of the dplyr package Select and filter data Be able to use magrittr pipes Create new columns with mutate() Use the split-apply-combine paradigm to summarize data Export data with write.csv() Bracket subsetting is handy, but it can be cumbersome and difficult to read, especially for complicated operations. Enter dplyr. dplyr is a package for making data manipulation easier. Packages in R are basically sets of additional functions that let you do more stuff. The functions we’ve been using so far, like str() or data.frame(), come built into R; packages give you access to more of them. Before you use a package for the first time you need to install it on your machine, and then you should import it in every subsequent R session when you need it. install.packages(&quot;dplyr&quot;) You might get asked to choose a CRAN mirror – this is basically asking you to choose a site to download the package from. The choice doesn’t matter too much; we recommend the RStudio mirror. library(&quot;dplyr&quot;) ## load the package 6.1 What is dplyr? The package dplyr provides easy tools for the most common data manipulation tasks. It is built to work directly with data frames. The thinking behind it was largely inspired by the package plyr which has been in use for some time but suffered from being slow in some cases.dplyr addresses this by porting much of the computation to C++. An additional feature is the ability to work directly with data stored in an external database. The benefits of doing this are that the data can be managed natively in a relational database, queries can be conducted on that database, and only the results of the query returned. This addresses a common problem with R in that all operations are conducted in memory and thus the amount of data you can work with is limited by available memory. The database connections essentially remove that limitation in that you can have a database of many 100s GB, conduct queries on it directly, and pull back just what you need for analysis in R. To learn more about dplyr after the workshop, you may want to check out this handy dplyr cheatsheet. 6.2 Selecting columns and filtering rows We’re going to learn some of the most common dplyr functions: select(), filter(), mutate(), group_by(), and summarize(). To select columns of a data frame, use select(). The first argument to this function is the data frame (surveys), and the subsequent arguments are the columns to keep. select(surveys, plot_id, species_id, weight) To choose rows, use filter(): filter(surveys, year == 1995) 6.3 Pipes But what if you wanted to select and filter at the same time? There are three ways to do this: use intermediate steps, nested functions, or pipes. With the intermediate steps, you essentially create a temporary data frame and use that as input to the next function. This can clutter up your workspace with lots of objects. You can also nest functions (i.e. one function inside of another). This is handy, but can be difficult to read if too many functions are nested as the process from inside out. The last option, pipes, are a fairly recent addition to R. Pipes let you take the output of one function and send it directly to the next, which is useful when you need to do many things to the same data set. Pipes in R look like %&gt;% and are made available via the magrittr package installed as part of dplyr. surveys %&gt;% filter(weight &lt; 5) %&gt;% select(species_id, sex, weight) In the above we use the pipe to send the surveys data set first through filter, to keep rows where weight was less than 5, and then through select to keep the species and sex columns. When the data frame is being passed to the filter() and select() functions through a pipe, we don’t need to include it as an argument to these functions anymore. If we wanted to create a new object with this smaller version of the data we could do so by assigning it a new name: surveys_sml &lt;- surveys %&gt;% filter(weight &lt; 5) %&gt;% select(species_id, sex, weight) surveys_sml Note that the final data frame is the leftmost part of this expression. 6.3 Challenge Using pipes, subset the data to include individuals collected before 1995, and retain the columns year, sex, and weight. % filter(year % select(year, sex, weight) ``` ---> 6.3.1 Mutate Frequently you’ll want to create new columns based on the values in existing columns, for example to do unit conversions, or find the ratio of values in two columns. For this we’ll use mutate(). To create a new column of weight in kg: surveys %&gt;% mutate(weight_kg = weight / 1000) If this runs off your screen and you just want to see the first few rows, you can use a pipe to view the head() of the data (pipes work with non-dplyr functions too, as long as the dplyr or magrittr packages are loaded). surveys %&gt;% mutate(weight_kg = weight / 1000) %&gt;% head The first few rows are full of NAs, so if we wanted to remove those we could insert a filter() in this chain: surveys %&gt;% filter(!is.na(weight)) %&gt;% mutate(weight_kg = weight / 1000) %&gt;% head is.na() is a function that determines whether something is or is not an NA. The ! symbol negates it, so we’re asking for everything that is not an NA. 6.3.1 Challenge Create a new dataframe from the survey data that meets the following criteria: contains only the species_id column and a column that contains values that are half the hindfoot_length values (e.g. a new column hindfoot_half). In this hindfoot_half column, there are no NA values and all values are &lt; 30. Hint: think about how the commands should be ordered to produce this data frame! % filter(!is.na(hindfoot_length)) %>% mutate(hindfoot_half = hindfoot_length / 2) %>% filter(hindfoot_half % select(species_id, hindfoot_half) ``` ---> 6.3.2 Split-apply-combine data analysis and the summarize() function Many data analysis tasks can be approached using the “split-apply-combine” paradigm: split the data into groups, apply some analysis to each group, and then combine the results. dplyr makes this very easy through the use of the group_by() function. 6.3.2.1 The summarize() function group_by() is often used together with summarize() which collapses each group into a single-row summary of that group. group_by() takes as argument the column names that contain the categorical variables for which you want to calculate the summary statistics. So to view mean the weight by sex: surveys %&gt;% group_by(sex) %&gt;% summarize(mean_weight = mean(weight, na.rm = TRUE)) You can group by multiple columns too: surveys %&gt;% group_by(sex, species_id) %&gt;% summarize(mean_weight = mean(weight, na.rm = TRUE)) When grouping both by “sex” and “species_id”, the first rows are for individuals that escaped before their sex could be determined and weighted. You may notice that the last column does not contain NA but NaN (which refers to “Not a Number”). To avoid this, we can remove the missing values for weight before we attempt to calculate the summary statistics on weight. Because the missing values are removed, we can omit na.rm=TRUE when computing the mean: surveys %&gt;% filter(!is.na(weight)) %&gt;% group_by(sex, species_id) %&gt;% summarize(mean_weight = mean(weight)) You may also have noticed, that the output from these calls don’t run off the screen anymore. That’s because dplyr has changed our data.frame to a tbl_df. This is a data structure that’s very similar to a data frame; for our purposes the only difference is that it won’t automatically show tons of data going off the screen, while displaying the data type for each column under its name. If you want to display more data on the screen, you can add the print() function at the end with the argument n specifying the number of rows to display: surveys %&gt;% filter(!is.na(weight)) %&gt;% group_by(sex, species_id) %&gt;% summarize(mean_weight = mean(weight)) %&gt;% print(n=15) Once the data is grouped, you can also summarize multiple variables at the same time (and not necessarily on the same variable). For instance, we could add a column indicating the minimum weight for each species for each sex: surveys %&gt;% filter(!is.na(weight)) %&gt;% group_by(sex, species_id) %&gt;% summarize(mean_weight = mean(weight), min_weight = min(weight)) 6.3.2.2 Tallying When working with data, it is also common to want to know the number of observations found for each factor or combination of factors. For this, dplyr provides tally(). For example, if we wanted to group by sex and find the number of rows of data for each sex, we would do: surveys %&gt;% group_by(sex) %&gt;% tally() Here, tally() is the action applied to the groups created by group_by() and counts the total number of records for each category. 6.3.2.2 Challenge How many individuals were caught in each plot_type surveyed? 6.3.2.2 Challenge Use group_by() and summarize() to find the mean, min, and max hindfoot length for each species (using species _id). 6.3.2.2 Challenge What was the heaviest animal measured in each year? Return the columns year, genus, species_id, and weight. 6.4 Exporting data Now that you have learned how to use dplyr to extract the information you need from the raw data, or to summarize your raw data, you may want to export these new datasets to share them with your collaborators or for archival. Similarly to the read.csv() function used to read in CSV into R, there is a write.csv() function that generates CSV files from data frames. Before using it, we are going to create a new folder, data_output in our working directory that will store this generated dataset. We don’t want to write generated datasets in the same directory as our raw data. It’s good practice to keep them separate. The data folder should only contain the raw, unaltered data, and should be left alone to make sure we don’t delete or modify it; on the other end the content of data_output directory will be generated by our script, and we know that we can delete the files it contains because we have the script that can re-generate these files. In preparation for our next lesson on plotting, we are going to prepare a cleaned up version of the dataset that doesn’t include any missing data. Let’s start by removing observations for which the species_id is missing. In this dataset, the missing species are represented by an empty string and not an NA. Let’s also remove observations for which weight and the hindfoot_length are missing. This dataset will also only contain observations of animals for which the sex has been determined: surveys_complete &lt;- surveys %&gt;% filter(species_id != &quot;&quot;, # remove missing species_id !is.na(weight), # remove missing weight !is.na(hindfoot_length), # remove missing hindfoot_length sex != &quot;&quot;) # remove missing sex Because we are interested in plotting how species abundances have changed through time, we are also going to remove observations for rare species (i.e., that have been observed less than 50 times). We will do this in two steps: first we are going to create a dataset that counts how often each species has been observed, and filter out the rare species; then, we will extract only the observations for these more common species: ## Extract the most common species_id species_counts &lt;- surveys_complete %&gt;% group_by(species_id) %&gt;% tally %&gt;% filter(n &gt;= 50) %&gt;% select(species_id) ## Only keep the most common species surveys_complete &lt;- surveys_complete %&gt;% filter(species_id %in% species_counts$species_id) To make sure that everyone has the same dataset, check that surveys_complete has 30463 rows and 13 columns by typing dim(surveys_complete). Now that our dataset is ready, we can save it as a CSV file in our data_output folder. By default, write.csv() includes a column with row names (in our case the names are just the row numbers), so we need to add row.names = FALSE so they are not included: write.csv(surveys_complete, file=&quot;data_output/surveys_complete.csv&quot;, row.names=FALSE) "],
["vis-ggplot2.html", "Chapter 7 Data visualization with ggplot2 7.1 Plotting with ggplot2 7.2 Building your plots iteratively 7.3 Boxplot 7.4 Plotting time series data 7.5 Faceting 7.6 Challenge 7.7 Customization 7.8 Making Plots Interactive with Plotly", " Chapter 7 Data visualization with ggplot2 7.0.0.1 Disclaimer We will be using the functions in the ggplot2 package. R has powerful built-in plotting capabilities, but for this exercise, we will be using the ggplot2 package, which facilitates the creation of highly-informative plots of structured data. 7.0.0.1 Learning Objectives Visualize some of the mammals data from Figshare surveys.csv Understand how to plot these data using R ggplot2 package. For more details on using ggplot2 see official documentation. Building step by step complex plots with the ggplot2 package Load required packages # plotting package library(ggplot2) # modern data frame manipulations library(dplyr) 7.1 Plotting with ggplot2 We will make the same plot using the ggplot2 package. ggplot2 is a plotting package that makes it simple to create complex plots from data in a dataframe. It uses default settings, which help creating publication quality plots with a minimal amount of settings and tweaking. ggplot graphics are built step by step by adding new elements. To build a ggplot we need to: bind the plot to a specific data frame using the data argument ggplot(data = surveys_complete) define aesthetics (aes), that maps variables in the data to axes on the plot or to plotting size, shape color, etc., ggplot(data = surveys_complete, aes(x = weight, y = hindfoot_length)) add geoms – graphical representation of the data in the plot (points, lines, bars). To add a geom to the plot use + operator: ggplot(data = surveys_complete, aes(x = weight, y = hindfoot_length)) + geom_point() The + in the ggplot2 package is particularly useful because it allows you to modify existing ggplot objects. This means you can easily set up plot “templates” and conveniently explore different types of plots, so the above plot can also be generated with code like this: # Create surveys_plot &lt;- ggplot(data = surveys_complete, aes(x = weight, y = hindfoot_length)) # Draw the plot surveys_plot + geom_point() Notes: Anything you put in the ggplot() function can be seen by any geom layers that you add. i.e. these are universal plot settings. This includes the x and y axis you set up in aes(). You can also specify aesthetics for a given geom independently of the aesthetics defined globally in the ggplot() function. 7.2 Building your plots iteratively Building plots with ggplot is typically an iterative process. We start by defining the dataset we’ll use, lay the axes, and choose a geom. ggplot(data = surveys_complete, aes(x = weight, y = hindfoot_length)) + geom_point() Then, we start modifying this plot to extract more infromation from it. For instance, we can add transparency (alpha) to avoid overplotting. ggplot(data = surveys_complete, aes(x = weight, y = hindfoot_length)) + geom_point(alpha = 0.1) We can also add colors for all the points ggplot(data = surveys_complete, aes(x = weight, y = hindfoot_length)) + geom_point(alpha = 0.1, color = &quot;blue&quot;) Or to color each species in the plot differently: ggplot(data = surveys_complete, aes(x = weight, y = hindfoot_length)) + geom_point(alpha = 0.1, aes(color=species_id)) 7.3 Boxplot Visualising the distribution of weight within each species. ggplot(data = surveys_complete, aes(x = species_id, y = hindfoot_length)) + geom_boxplot() By adding points to boxplot, we can have a better idea of the number of measurements and of their distribution: ggplot(data = surveys_complete, aes(x = species_id, y = hindfoot_length)) + geom_boxplot(alpha = 0) + geom_jitter(alpha = 0.3, color = &quot;tomato&quot;) Notice how the boxplot layer is behind the jitter layer? What do you need to change in the code to put the boxplot in front of the points such that it’s not hidden. 7.3 Challenges Boxplots are useful summaries, but hide the shape of the distribution. For example, if there is a bimodal distribution, this would not be observed with a boxplot. An alternative to the boxplot is the violin plot (sometimes known as a beanplot), where the shape (of the density of points) is drawn. Replace the box plot with a violin plot; see geom_violin() In many types of data, it is important to consider the scale of the observations. For example, it may be worth changing the scale of the axis to better distribute the observations in the space of the plot. Changing the scale of the axes is done similarly to adding/modifying other components (i.e., by incrementally adding commands). Represent weight on the log10 scale; see scale_y_log10() Create boxplot for hindfoot_length. 7.4 Plotting time series data Let’s calculate number of counts per year for each species. To do that we need to group data first and count records within each group. yearly_counts &lt;- surveys_complete %&gt;% group_by(year, species_id) %&gt;% tally Timelapse data can be visualised as a line plot with years on x axis and counts on y axis. ggplot(data = yearly_counts, aes(x = year, y = n)) + geom_line() Unfortunately this does not work, because we plot data for all the species together. We need to tell ggplot to draw a line for each species by modifying the aesthetic function to include group = species_id. ggplot(data = yearly_counts, aes(x = year, y = n, group = species_id)) + geom_line() We will be able to distinguish species in the plot if we add colors. ggplot(data = yearly_counts, aes(x = year, y = n, group = species_id, colour = species_id)) + geom_line() 7.5 Faceting ggplot has a special technique called faceting that allows to split one plot into multiple plots based on a factor included in the dataset. We will use it to make one plot for a time series for each species. ggplot(data = yearly_counts, aes(x = year, y = n, group = species_id, colour = species_id)) + geom_line() + facet_wrap(~ species_id) Now we would like to split line in each plot by sex of each individual measured. To do that we need to make counts in data frame grouped by year, species_id, and sex: yearly_sex_counts &lt;- surveys_complete %&gt;% group_by(year, species_id, sex) %&gt;% tally We can now make the faceted plot splitting further by sex (within a single plot): ggplot(data = yearly_sex_counts, aes(x = year, y = n, color = species_id, group = sex)) + geom_line() + facet_wrap(~ species_id) Usually plots with white background look more readable when printed. We can set the background to white using the function theme_bw(). ggplot(data = yearly_sex_counts, aes(x = year, y = n, color = species_id, group = sex)) + geom_line() + facet_wrap(~ species_id) + theme_bw() To make the plot easier to read, we can color by sex instead of species (species are already in separate plots, so we don’t need to distinguish them further). ggplot(data = yearly_sex_counts, aes(x = year, y = n, color = sex, group = sex)) + geom_line() + facet_wrap(~ species_id) + theme_bw() 7.6 Challenge Use what you just learned to create a plot that depicts how the average weight of each species changes through the years. % group_by(year, species_id) %>% summarise(avg_weight = mean(weight)) ggplot(data = yearly_weight, aes(x=year, y=avg_weight, color = species_id, group = species_id)) + geom_line() + facet_wrap(~ species_id) + theme_bw() ``` --> The facet_wrap geometry extracts plots into an arbitrary number of dimensions to allow them to cleanly fit on one page. On the other hand, the facet_grid geometry allows you to explicitly specify how you want your plots to be arranged via formula notation (rows ~ columns; a . can be used as a placeholder that indicates only one row or column). Let’s modify the previous plot to compare how the weights of male and females has changed through time. ## One column, facet by rows yearly_sex_weight &lt;- surveys_complete %&gt;% group_by(year, sex, species_id) %&gt;% summarize(avg_weight = mean(weight)) ggplot(data = yearly_sex_weight, aes(x=year, y=avg_weight, color = species_id, group = species_id)) + geom_line() + facet_grid(sex ~ .) # One row, facet by column ggplot(data = yearly_sex_weight, aes(x=year, y=avg_weight, color = species_id, group = species_id)) + geom_line() + facet_grid(. ~ sex) 7.7 Customization Take a look at the ggplot2 cheat sheet (https://www.rstudio.com/wp-content/uploads/2015/08/ggplot2-cheatsheet.pdf), and think of ways to improve the plot. You can write down some of your ideas as comments in the Etherpad. Now, let’s change names of axes to something more informative than ‘year’ and ‘n’ and add a title to this figure: ggplot(data = yearly_sex_counts, aes(x = year, y = n, color = sex, group = sex)) + geom_line() + facet_wrap(~ species_id) + labs(title = &#39;Observed species in time&#39;, x = &#39;Year of observation&#39;, y = &#39;Number of species&#39;) + theme_bw() The axes have more informative names, but their readibility can be improved by increasing the font size. While we are at it, we’ll also change the font family: ggplot(data = yearly_sex_counts, aes(x = year, y = n, color = sex, group = sex)) + geom_line() + facet_wrap(~ species_id) + labs(title = &#39;Observed species in time&#39;, x = &#39;Year of observation&#39;, y = &#39;Number of species&#39;) + theme_bw() + theme(text=element_text(size=16, family=&quot;Arial&quot;)) After our manipulations we notice that the values on the x-axis are still not properly readable. Let’s change the orientation of the labels and adjust them vertically and horizontally so they don’t overlap. You can use a 90 degree angle, or experiment to find the appropriate angle for diagonally oriented labels. ggplot(data = yearly_sex_counts, aes(x = year, y = n, color = sex, group = sex)) + geom_line() + facet_wrap(~ species_id) + labs(title = &#39;Observed species in time&#39;, x = &#39;Year of observation&#39;, y = &#39;Number of species&#39;) + theme_bw() + theme(axis.text.x = element_text(colour=&quot;grey20&quot;, size=12, angle=90, hjust=.5, vjust=.5), axis.text.y = element_text(colour=&quot;grey20&quot;, size=12), text=element_text(size=16, family=&quot;Arial&quot;)) If you like the changes you created to the default theme, you can save them as an object to easily apply them to other plots you may create: arial_grey_theme &lt;- theme(axis.text.x = element_text(colour=&quot;grey20&quot;, size=12, angle=90, hjust=.5, vjust=.5), axis.text.y = element_text(colour=&quot;grey20&quot;, size=12), text=element_text(size=16, family=&quot;Arial&quot;)) ggplot(surveys_complete, aes(x = species_id, y = hindfoot_length)) + geom_boxplot() + arial_grey_theme With all of this information in hand, please take another five minutes to either improve one of the plots generated in this exercise or create a beautiful graph of your own. Use the RStudio ggplot2 cheat sheet, which we linked earlier for inspiration. Here are some ideas: See if you can change thickness of the lines. Can you find a way to change the name of the legend? What about its labels? Use a different color palette (see http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/) After creating your plot, you can save it to a file in your favourite format. You can easily change the dimension (and its resolution) of your plot by adjusting the appropriate arguments (width, height and dpi): my_plot &lt;- ggplot(data = yearly_sex_counts, aes(x = year, y = n, color = sex, group = sex)) + geom_line() + facet_wrap(~ species_id) + labs(title = &#39;Observed species in time&#39;, x = &#39;Year of observation&#39;, y = &#39;Number of species&#39;) + theme_bw() + theme(axis.text.x = element_text(colour=&quot;grey20&quot;, size=12, angle=90, hjust=.5, vjust=.5), axis.text.y = element_text(colour=&quot;grey20&quot;, size=12), text=element_text(size=16, family=&quot;Arial&quot;)) ggsave(&quot;name_of_file.png&quot;, my_plot, width=15, height=10) 7.8 Making Plots Interactive with Plotly You can make plots interactive by simply passing the ggplot2 object to the plotly library’s ggplot2 function. This is most useful for dense plots in which you wish to inspect a plot’s individual elements interactively, such as outliers in a scatterplot. This only works when outputting to HTML, since it takes advantage of the htmlwidgets framework. First load the library: library(plotly) # install.packages(&#39;plotly&#39;) #&gt; #&gt; Attaching package: &#39;plotly&#39; #&gt; The following object is masked from &#39;package:ggplot2&#39;: #&gt; #&gt; last_plot #&gt; The following object is masked from &#39;package:graphics&#39;: #&gt; #&gt; layout Let’s start with the first ggplot of a scatterplot. # get ggplot2 object for scatter plot p &lt;- ggplot(data = surveys_complete, aes(x = weight, y = hindfoot_length)) + geom_point(alpha = 0.1, aes(color=species_id)) # feed ggplot2 object to plotly::ggplotly() to make interactive ggplotly(p) Running the code above from within RStudio’s Console, outputs to a Viewer pane, rather than the Plots pane of previous ggplot2 functions. Hovering over any given point displays the information associated with that data point. Popup information on hover for scatterplot rendered through plotly::ggplotly() You can similarly make any other ggplot2 interactive, such as for a box plot: # box plot p &lt;- ggplot(data = surveys_complete, aes(x = species_id, y = hindfoot_length)) + geom_boxplot() ggplotly(p) Or for a line graph: # line graph p &lt;- ggplot(yearly_counts, aes(x = year, y = n, group = species_id, colour = species_id)) + geom_line() ggplotly(p) For more options, please visit plot.ly/ggplot2. "],
["r-and-sql.html", "Chapter 8 SQL databases and R 8 Learning Objectives 8.1 Introduction 8.2 Connecting R to sqlite databases 8.3 Running SQL queries from R 8.3 Challenge 8.4 Creating a SQLite DB using R 8.4 Challenge 8.4 Extra Challenge", " Chapter 8 SQL databases and R 8 Learning Objectives Students will be able to connect to an existing database using R Query an existing database through R using queries constructed with variables Create a database and populate it from R Understand that scripted database interactions enhance reproducibility of analysis 8.1 Introduction Interacting with databases through scripted languages can offer advantages over querying databases via a GUI interface. A GUI interface for your database is easier to use and allows the quick viewing of adhoc queries. Querying a database with a programatic interface (in this case R, but it could be any language) are slightly more complicated. However the trade-off is that data manipulations are preserved in the code. Aggregations, summaries and other database operations are preserved. Therefore those pre-analysis data manipulation steps are not lost and can be reproduced later by yourself or others. 8.2 Connecting R to sqlite databases R can connect to databases through a number of packages. In our case we will use RSQLite to connect to existing SQLite3 databases. However you should be able to connect to almost any database in R via JDBC or ODBC, or specific database packages (such as we are doing, or MySQL ). To begin these exercises we’ll connect to the mammal database you’ve just created. We’ll need the RSQLite package so be sure to install it first. install.packages('RSQLite'). library(RSQLite) #&gt; Loading required package: DBI ## Set dbname and driver out of convenience myDB &lt;- &quot;data/portal_mammals.sqlite&quot; conn &lt;- dbConnect(drv = SQLite(), dbname= myDB) Now we’re connected to our database, let’s explore the table structure in the database. Remember we could see the list of tables in the SQLite Firefox gui. In R, we’ll need to use SQL commands. 8.3 Running SQL queries from R We can view information about the database structure which includes a list of all tables like this: dbGetQuery(conn, &quot;SELECT type, tbl_name FROM sqlite_master&quot;) The RSQLite package also has functions that can be used to list both tables and fields within a table. Here you can see the types and names of fields and get a count of records. dbListTables(conn) #get list of fields in the surveys table dbListFields(conn,&quot;surveys&quot;) dbGetQuery(conn,&quot;SELECT count(*) FROM surveys&quot;) It’s good practice to always close a connection that you open in R. Let’s do that next. Note that once you’ve closed a connection, you will have to open a new connection to query and import the data again. dbDisconnect(conn) We’ve now covered the basics of connecting to a database and exploring its basic structure. From here we can write queries to access subsets of the data within our database, using the same methods that we used in SQLite. Let’s try some basic queries from the previous lesson. Querying simply takes a connection to a database and query as inputs and returns a dataframe with the results. Before we can do this, we need to re-establish a database connection. ## Set dbname and driver out of convenience myDB &lt;- &quot;data/portal_mammals.sqlite&quot; conn &lt;- dbConnect(drv = SQLite(), dbname= myDB) Next, we build our query. We can use the dbGetQuery function to run the query and access data returned in a data.frame object. q &lt;- &#39;SELECT DISTINCT year, species_id FROM surveys&#39; result &lt;- dbGetQuery(conn, q) head(result) 8.3 Challenge Write a query that returns counts of genus by plot_id You can join multiple tables together in SQL using the following syntax where foreign key refers to your unique id (e.g., species_id): SELECT table.col, table.col FROM table1 JOIN table2 ON table1.key = table2.key JOIN table3 ON table2.key = table3.key Write a query that joins the species, plot, and survey tables together. The query should return counts of genus by plot type. Then create a bar plot of your results in R. q &lt;- &quot;SELECT d.plot_type , c.genus, count(*) FROM (SELECT a.genus, b.plot_id FROM species a JOIN surveys b ON a.species_id = b.species_id) c JOIN plots d ON c.plot_id = d.plot_id GROUP BY d.plot_type,c.genus&quot; result &lt;- dbGetQuery(conn,q) head(result) All we’ve done so far is execute the same sorts of queries that can easily be made with a GUI. Now let’s try leveraging the power of scripted queries. Imagine you want to know how many rodents were found every other year. To get this we’ll get the range of dates from the database, sequence them by two and make new queries. yearRange &lt;- dbGetQuery(conn,&quot;SELECT min(year),max(year) FROM surveys&quot;) years &lt;- seq(yearRange[,1],yearRange[,2],by=2) Next we’ll build our query string using the paste() function. q &lt;- paste(&quot; SELECT a.year,b.taxa,count(*) as count FROM surveys a JOIN species b ON a.species_id = b.species_id AND b.taxa = &#39;Rodent&#39; AND a.year in (&quot;, paste(years,collapse=&quot;,&quot;) ,&quot;) GROUP BY a.year, b.taxa&quot;, sep = &quot;&quot; ) rCount &lt;- dbGetQuery(conn,q) head(rCount) With the nested paste commands we were able to construct a query programatically, without having to type out all the years. This could also be done with a for loop, especially if the query to be constructed is more complicated. 8.4 Creating a SQLite DB using R We can use R to create a new database and associated structure (also known as the schema) databases from existing csv files. Let’s recreate the mammals database that we’ve been working with, in R. First let’s read in the csv files. Up until now we been working with an existing data. However we can use R as a way to build up databases from existing flat files. We’ll use the flat files that make up the mammals database to recreate it. First let’s read in the files. species &lt;- read.csv(&quot;data/species.csv&quot;) surveys &lt;- read.csv(&quot;data/surveys.csv&quot;) plots &lt;- read.csv(&quot;data/plots.csv&quot;) Next we’ll need to create a database and add our tables. myDB &lt;- &quot;portalR.db&quot; myConn &lt;- dbConnect(drv = SQLite(), dbname= myDB) dbListTables(myConn) By opening up a connection, you’ve created a new database. If you list the tables you’ll see that the database is empty. Next we’ll add the dataframes we just read in to the database. dbWriteTable(myConn,&quot;species&quot;,species) dbListTables(myConn) dbGetQuery(myConn,&quot;SELECT * from species limit 10&quot;) If you check the location of our database you’ll see that data is automatically being written to disk. Not only does R and RSQLite provide easy ways to query existing databases, it also allows you to easily create your own databases from flat files. If you check the location of your database you’ll see that data is automatically being written to disk. Not only does R and RSQLite provide easy ways to query existing databases, it also allows you to easily create your own databases from flat files. 8.4 Challenge Add the remaining tables to the existing database. Open the new database using the Firefox SQLite manager to verify that the database was built successfully. 8.4 Extra Challenge Run some of your queries from earlier in the lesson to verify that you have faithfully recreated the mammals database. Don’t forget to close your database connection when you are done with it! "]
]
